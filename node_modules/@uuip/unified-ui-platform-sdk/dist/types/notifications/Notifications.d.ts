export declare namespace Notifications {
    export namespace ItemMeta {
        enum Type {
            Info = "info",
            Warn = "warn",
            Error = "error",
            Success = "success",
            Chat = "chat",
            Default = "default"
        }
        const TYPES: Type[];
        enum Mode {
            Silent = "silent",
            AutoDismiss = "autodismiss",
            Acknowledge = "acknowledge"
        }
        const MODES: Mode[];
        enum Status {
            Added = "added",
            Pended = "pended",
            Activated = "activated",
            Deactivated = "deactivated",
            Removed = "removed"
        }
        const StatusWeight: Readonly<Record<Status, number>>;
        const STATUSES: Status[];
        enum AddEventReason {
            User = "user_add"
        }
        enum PendingEventReason {
            ServiceAutoPropagate = "service_auto_propagate_pending",
            ServiceAutoDismiss = "service_autodismiss_pending",
            UserSilent = "user_silent_pending"
        }
        enum ActivateEventReason {
            ServiceAutoPropagate = "service_auto_propagate_activate"
        }
        enum DeactivateEventReason {
            UserNegative = "user_negative_deactivate",
            UserPositive = "user_positive_deactivate",
            UserNeutral = "user_neutral_deactivate"
        }
        enum RemoveEventReason {
            User = "user_remove"
        }
        type StatusChangeEventReason = AddEventReason | PendingEventReason | ActivateEventReason | DeactivateEventReason | RemoveEventReason;
        type Listeners = {
            statusUpdate: (status: Status, reason: StatusChangeEventReason) => void;
            modeUpdate: (mode: Mode) => void;
        };
        type Events = keyof Listeners;
        type ISOTimestamp = string;
        interface RawData {
            type: Type;
            mode: Mode;
            title: string;
            data: string | Record<string, any>;
            timestamp?: ISOTimestamp;
        }
        type Raw = {
            data: ItemMeta.RawData;
            options?: Partial<ItemMeta.Options>;
        };
        interface UserControlled {
            deactivate: (reason: DeactivateEventReason.UserNegative | DeactivateEventReason.UserPositive | DeactivateEventReason.UserNeutral) => void;
        }
        type Options = {
            AUTO_DISMISS_TIMEOUT: number;
        };
    }
    export namespace ServiceMeta {
        type Listeners = {
            add: (added_notifications: Notifications.Item[], reason: ItemMeta.StatusChangeEventReason) => void;
            pending: (pending_notifications: Notifications.Item[], reason: ItemMeta.StatusChangeEventReason) => void;
            activate: (activated_notifications: Notifications.Item[], reason: ItemMeta.StatusChangeEventReason) => void;
            deactivate: (deactivated_notifications: Notifications.Item[], reason: ItemMeta.StatusChangeEventReason) => void;
            remove: (removed_notifications: Notifications.Item[], reason: ItemMeta.StatusChangeEventReason) => void;
        };
        type Events = keyof Listeners;
        type HubListeners = {
            statusServiceUpdateRequest: (notification: Notifications.Item | Notifications.Item[], status: ItemMeta.Status, reason: ItemMeta.StatusChangeEventReason) => void;
            statusServiceUpdateResponse: (notificationsMap: Record<Notifications.Item["timestamp"], Notifications.Item>, status: ItemMeta.Status, reason: ItemMeta.StatusChangeEventReason) => void;
            modeStatusUpdateResponse: (notificationsMap: Record<Notifications.Item["timestamp"], Notifications.Item>, mode: ItemMeta.Mode) => void;
        };
        type HubEvents = keyof HubListeners;
        const STATUS_EVENTS: ServiceMeta.Events[];
        const STATUS_EVENT_MAP: Record<ServiceMeta.Events, ItemMeta.Status>;
        type ConfigItemModeDisabled = Record<Notifications.ItemMeta.Mode, boolean>;
        type ConfigItemModeLimit = Record<Notifications.ItemMeta.Mode, number>;
        type Config = {
            DISABLED_ITEM_MODE: ConfigItemModeDisabled;
            ACTIVATED_ITEM_MODE_LIMIT: ConfigItemModeLimit;
            AUTO_DISMISS_TIMEOUT: number;
        };
        type UpdateConfig = Partial<Config> | {
            DISABLED_ITEM_MODE?: Partial<ConfigItemModeDisabled>;
            ACTIVATED_ITEM_MODE_LIMIT?: Partial<Pick<ConfigItemModeLimit, ItemMeta.Mode.AutoDismiss>>;
        };
        type ConfigKeys = keyof Config;
        type StatusHolderCollection = Notifications.Item[] & Record<"ids", ItemMeta.ISOTimestamp[]> & Record<ItemMeta.Mode, Notifications.Item[]> & Record<ItemMeta.Type, Notifications.Item[]>;
        const DISABLED_ITEM_MODE: Record<ItemMeta.Mode, boolean>;
        const ACTIVATED_ITEM_MODE_LIMIT: Record<ItemMeta.Mode, number>;
        const AUTO_DISMISS_TIMEOUT = 5000;
    }
    class ServiceHubAdapter {
        private readonly hubEmitter;
        emit<T extends ServiceMeta.HubEvents>(eventName: T, ...args: Parameters<ServiceMeta.HubListeners[T]>): void;
        addEventListener<T extends ServiceMeta.HubEvents>(eventName: T, listener: ServiceMeta.HubListeners[T]): void;
        addOnceEventListener<T extends ServiceMeta.HubEvents>(eventName: T, listener: ServiceMeta.HubListeners[T]): void;
        removeEventListener<T extends ServiceMeta.HubEvents>(eventName: T, listener: ServiceMeta.HubListeners[T]): void;
        removeAllEventListeners(): void;
    }
    export class Item implements ItemMeta.RawData, ItemMeta.UserControlled {
        readonly type: ItemMeta.RawData["type"];
        readonly title: ItemMeta.RawData["title"];
        readonly data: ItemMeta.RawData["data"];
        readonly timestamp: ItemMeta.ISOTimestamp;
        readonly datetime: string | null;
        readonly options: Partial<ItemMeta.Options>;
        private readonly _serviceHubAdapter?;
        private readonly _serviceHubSubscriptions;
        private readonly _itemEmitter;
        private _status?;
        private _reason?;
        private _mode;
        get status(): ItemMeta.Status | undefined;
        get reason(): ItemMeta.StatusChangeEventReason | undefined;
        get mode(): ItemMeta.Mode;
        private validateAuxOptions;
        constructor(raw: ItemMeta.Raw, serviceHubAdapter?: ServiceHubAdapter);
        private bindItemHubListeners;
        private unbindItemHubListeners;
        deactivate(reason: ItemMeta.DeactivateEventReason): void;
        pending(): void;
        private emit;
        addEventListener<T extends ItemMeta.Events>(eventName: T, listener: ItemMeta.Listeners[T]): void;
        addOnceEventListener<T extends ItemMeta.Events>(eventName: T, listener: ItemMeta.Listeners[T]): void;
        removeEventListener<T extends ItemMeta.Events>(eventName: T, listener: ItemMeta.Listeners[T]): void;
        removeAllEventListeners(): void;
    }
    export class Service {
        private readonly emitter;
        private map;
        private status;
        private serviceConfig;
        private activeAutoDismissTimeoutRefs;
        constructor();
        private static mergeConfig;
        private static createStatus;
        private static createStatusHolderCollection;
        private static createStatusHolderSubCollections;
        private updateNotificationsCollections;
        private setAutoDismiss;
        private removeAutoDismiss;
        private update;
        private propagate;
        private prepareAddNotifications;
        private prepareUpdateNotifications;
        private prepareActiveCandidatesNotifications;
        static sortTimestampsFn: (timestamp1: string, timestamp2: string) => 1 | 0 | -1;
        static sortByTimestampsFn(n1: Notifications.Item, n2: Notifications.Item): 1 | 0 | -1;
        get added(): ServiceMeta.StatusHolderCollection;
        get pended(): ServiceMeta.StatusHolderCollection;
        get activated(): ServiceMeta.StatusHolderCollection;
        get deactivated(): ServiceMeta.StatusHolderCollection;
        getNotificationStatus(notification: Notifications.Item): ItemMeta.Status | undefined;
        get config(): ServiceMeta.Config;
        private static validateUpdateConfig;
        updateConfig(config: ServiceMeta.UpdateConfig): void;
        add(raw: ItemMeta.Raw | ItemMeta.Raw[]): Item[];
        pending(notification: Notifications.Item | Notifications.Item[]): Item[];
        deactivate(notification: Notifications.Item | Notifications.Item[], reason: ItemMeta.DeactivateEventReason): Item[];
        remove(notification: Notifications.Item | Notifications.Item[]): Item[];
        pendingAllActivated(): Item[];
        pendingAll(): Item[];
        deactivateAllActivated(reason: ItemMeta.DeactivateEventReason): Item[];
        deactivateAll(reason: ItemMeta.DeactivateEventReason): Item[];
        removeAllDeactivated(): Item[];
        removeAll(): Item[];
        addEventListener<T extends ServiceMeta.Events>(eventName: T, listener: ServiceMeta.Listeners[T]): void;
        removeEventListener<T extends ServiceMeta.Events>(eventName: T, listener: ServiceMeta.Listeners[T]): void;
        addOnceEventListener<T extends ServiceMeta.Events>(eventName: T, listener: ServiceMeta.Listeners[T]): void;
        removeAllEventListeners(): void;
        private emit;
        private readonly serviceHubAdapter;
        private bindServiceHubEvents;
    }
    export {};
}
export declare function createNotifications(config?: Notifications.ServiceMeta.UpdateConfig): Notifications.Service;
