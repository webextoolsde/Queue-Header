import { Signal, Err as UUIPErr } from "@uuip/unified-ui-platform-sdk";
import { AxiosError, AxiosResponse } from "axios";
import { AqmNotifs } from "./aqm-notifs";
export declare const TIMEOUT_REQ = 20000;
export declare class AqmReqs {
    private pendingRequests;
    private pendingEvents;
    private pendingNotifCancelrequest;
    private readonly auth;
    constructor(notifs: AqmNotifs);
    req<TRes, TErr, TReq>(c: Conf<TRes, TErr, TReq>): Res<TRes, TReq>;
    reqEmpty<TRes, TErr>(c: ConfEmpty<TRes, TErr>): ResEmpty<TRes>;
    evt<T>(p: EvtConf<T>): EvtRes<T>;
    private fetchNewToken;
    private makeAPIRequest;
    private createPromise;
    private bindPrint;
    private bindCheck;
    private readonly identifyInteractionIsTaskObject;
    private isFlowValuesEncrypted;
    private isValidCADFlowValue;
    private isValidCPDFlowValue;
    private getDecompressedValue;
    private readonly onMessage;
    /**
     * This method is a temporary workaround to handle the message from the websocket worker as it
     * does not require a lambda. Not using a lambda simplifies unit test.
     * Once we remove main thread websocket and aqm-notifs, we can rename this method OnMessage and
     * get rid of the lambda (but keep the code inside it).
     * @param message
     */
    onMessageForWebsocketWorker(message: any): void;
    private onMessageImp;
}
declare module "@uuip/unified-ui-platform-sdk" {
    namespace Err {
        interface Ids {
            "Service.aqm.reqs": ReqError;
        }
    }
}
export type Msg<T = any> = {
    type: string;
    orgId: string;
    trackingId: string;
    data: T;
};
type ReqError = "Service.aqm.reqs.GenericRequestError" | {
    "Service.aqm.reqs.Pending": {
        key: string;
        msg: string;
    };
} | {
    "Service.aqm.reqs.PendingEvent": {
        key: string;
    };
} | {
    "Service.aqm.reqs.Timeout": {
        key: string;
        resAxios: AxiosResponse;
    };
} | {
    "Service.aqm.reqs.TimeoutEvent": {
        key: string;
    };
};
type BindType = string | string[] | {
    [key: string]: BindType;
};
interface Bind {
    type: BindType;
    data?: any;
}
type updateMethods = "get" | "post" | "put" | "patch";
type Req<TRes, TErr> = {
    url: string;
    host?: string;
    method?: updateMethods;
    err?: ((errObj: AxiosError<any>) => UUIPErr.Details<"Service.reqs.generic.failure">) | UUIPErr.IdsMessage | ((e: AxiosError) => UUIPErr.Message | UUIPErr.Details<UUIPErr.IdsDetails>);
    notifSuccess: {
        bind: Bind;
        msg: TRes;
    };
    notifFail?: {
        bind: Bind;
        errMsg: TErr;
        err: (e: TErr) => UUIPErr.Details<UUIPErr.IdsDetails>;
    } | {
        bind: Bind;
        errId: UUIPErr.IdsDetails;
    };
    data?: any;
    headers?: Record<string, string>;
    timeout?: Timeout;
    notifCancel?: {
        bind: Bind;
        msg: TRes;
    };
};
export type Timeout = number | "disabled";
type Conf<TRes, TErr, TReq> = (p: TReq) => Req<TRes, TErr>;
type ConfEmpty<TRes, TErr> = () => Req<TRes, TErr>;
export type Res<TRes, TReq> = (p: TReq, cbRes?: CbRes<TRes>) => Promise<TRes>;
export type ResEmpty<TRes> = (cbRes?: CbRes<TRes>) => Promise<TRes>;
type CbRes<TRes> = (res: any) => void | TRes;
type EvtConf<T> = {
    bind: Bind;
    msg: T;
};
type EvtRes<T> = Signal.WithData<T> & {
    listenOnceAsync: (p?: {
        resolveIf?: (msg: T) => boolean;
        timeout?: Timeout;
    }) => Promise<T>;
};
export {};
//# sourceMappingURL=aqm-reqs.d.ts.map