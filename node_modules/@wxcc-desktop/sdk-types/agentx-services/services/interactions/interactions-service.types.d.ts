import type { SetIntervalAsyncTimer } from "set-interval-async/dynamic";
import { InteractionsServiceConstants } from "./interactions-service-constants";
export declare namespace InteractionsServiceTypes {
    interface SortBy {
        fields: InteractionsServiceConstants.QueryField[];
        order: InteractionsServiceConstants.SortOrder;
    }
    interface Filter {
        filterType: InteractionsServiceConstants.FilterType;
        filter: string | number | boolean;
        operator: InteractionsServiceConstants.FilterOperator;
    }
    type Filters = Partial<Record<InteractionsServiceConstants.QueryField, Filter[]>>;
    interface SearchResults {
        tasks: TaskDetails[];
        pageInfo: PageInfo;
    }
    interface PageInfo {
        endCursor: string;
        hasNextPage: boolean;
    }
    interface TaskDetails {
        id: string;
        status: string;
        channelType: string;
        createdTime: number;
        endedTime: number;
        origin: string;
        destination: string;
        contactReason: string;
        direction: string;
        channelSubType: string;
        customer: Customer;
        isActive: boolean;
        channelMetaData: ChannelMetaData;
        lastQueue: QueueInfo;
        lastSite: NameIdInfo;
        lastTeam: NameIdInfo;
        lastEntryPoint: NameIdInfo;
        previousQueue: NameIdInfo;
        lastWrapUpCodeId: string;
        lastWrapupCodeName: string;
        lastAgent: Agent;
        emailBccList: string;
        emailCcList: string;
        emailToList: string;
        totalDuration: number;
        csatScore: number;
        blindTransferCount: number;
        conferenceCount: number;
        conferenceDuration: number;
        consultCount: number;
        consultDuration: number;
        holdCount: number;
        holdDuration: number;
        connectedCount: number;
        connectedDuration: number;
        transferCount: number;
        wrapupDuration: number;
        ringingDuration: number;
        queueDuration: number;
        queueCount: number;
        callCompletedCount: number;
        sentiment: string;
        autoCsat: string;
        matchedSkills: string;
        requiredSkills: string;
        matchedSkillsProfile: string;
        isWithInServiceLevel: boolean;
        isContactHandled: boolean;
        previousAgentId: string;
        previousAgentSessionId: string;
        previousAgentName: string;
        isOutdial: boolean;
        agentToQueueTransferCount: number;
        lastActivityTime: number;
        aggregation: any;
        actions: string;
    }
    interface Customer {
        name: string;
        phoneNumber: string;
        email: string;
    }
    interface ChannelMetaData {
        email: {
            subject: string;
        };
        chat: {
            chatReason: string;
        };
    }
    interface QueueInfo {
        id: string;
        name: string;
        duration: number;
    }
    interface NameIdInfo {
        id: string;
        name: string;
    }
    interface Agent {
        id: string;
        name: string;
        signInId: string;
        sessionId: string;
        phoneNumber: string;
        channelId: string;
    }
    interface FetchInteractionsParams {
        startTime: number;
        endTime: number;
        cursor: string;
        sortBy?: InteractionsServiceTypes.SortBy;
        filters?: InteractionsServiceTypes.Filters;
    }
    type InteractionsDelta = {
        fullUpdate?: InteractionsServiceTypes.TaskDetails[];
        updated?: InteractionsServiceTypes.TaskDetails[];
        removed?: string[];
    };
    interface InteractionsUpdate {
        fullUpdate?: TaskDetails[];
        realTimeUpdate?: {
            updated: TaskDetails[];
            removed: string[];
        };
    }
    type ActiveOrQueuedInteractions = InteractionsServiceConstants.QueryType.Active | InteractionsServiceConstants.QueryType.Queued;
    type QueuedOrCompletedInteractions = InteractionsServiceConstants.QueryType.Queued | InteractionsServiceConstants.QueryType.Completed;
    type CompletedResponse = {
        fetchMore: () => Promise<boolean>;
    };
    type PollingResponse = {
        intervalId: SetIntervalAsyncTimer;
        fetchMore: () => Promise<boolean>;
    };
    type ContactStatsSubscription = {
        unsubscribe: () => void;
    };
    type RealTimeCallback = (data: InteractionsServiceTypes.InteractionsUpdate) => void;
    type PollingCallback = (data: InteractionsServiceTypes.TaskDetails[]) => void;
}
//# sourceMappingURL=interactions-service.types.d.ts.map