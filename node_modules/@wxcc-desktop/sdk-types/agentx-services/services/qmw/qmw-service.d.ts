import { Service } from "../../index";
import QMW = Service.QMW;
type ErrDetails = {
    trackingId: string;
    msg: string;
    statusCode: number;
    retryAfter: string;
};
export type qmwErrorIds = {
    "Service.qmw.fetchTasks": ErrDetails;
} | {
    "Service.qmw.fetchCapture": ErrDetails;
} | {
    "Service.qmw.fetchCaptureMetaData": ErrDetails;
};
export declare function qmwService(): {
    fetchTasks: (p: {
        startTime: number;
        endTime: number;
        pageNumber: number;
    }, cb?: ((res: any) => void | QMW.SearchResults) | undefined) => Promise<QMW.SearchResults>;
    fetchCaptureMetaData: (p: {
        taskId: string;
        startTime: number;
    }, cb?: ((res: any) => void | QMW.CaptureMetaDataResults) | undefined) => Promise<QMW.CaptureMetaDataResults>;
    fetchCapture: (p: {
        taskId: string;
    }, cb?: ((res: any) => void | QMW.CaptureResults) | undefined) => Promise<QMW.CaptureResults>;
};
declare module "@uuip/unified-ui-platform-sdk" {
    namespace Err {
        interface Ids {
            "Service.qmw": qmwErrorIds;
        }
    }
}
declare module "../../index" {
    namespace Service.QMW {
        type SearchResults = {
            data: {
                task: {
                    pageInfo: PageInfo;
                    tasks: TaskMap[];
                };
            };
        };
        type PageInfo = {
            hasNextPage: boolean;
            endCursor: string;
        };
        type TaskPropertyMap = {
            name: string;
        };
        type TaskMap = {
            id: string;
            connectedDuration: number;
            destination: string;
            createdTime: number;
            origin: string;
            autoCsat: number | null;
            owner: TaskPropertyMap;
            lastQueue: TaskPropertyMap;
            lastTeam: TaskPropertyMap;
            lastWrapupCodeName: string;
        };
        type CaptureMetaDataResults = {
            data: {
                taskDetails: {
                    tasks: TaskMetaData[];
                };
            };
        };
        type TaskMetaData = {
            id: string;
            activities: {
                nodes: Activity[];
            };
        };
        type Activity = {
            eventName: string;
            createdTime: number;
            endedTime: number;
            duration: number;
            agentName: string;
            destinationAgentName: string;
            agentId?: string;
        };
        type CaptureResults = {
            meta: {
                orgId: string;
                urlExpiration: number;
            };
            data: CapturesData[];
        };
        type CapturesData = {
            taskId: string;
            recording: RecordingData[];
            transcription: TranscriptionData[];
        };
        type RecordingData = {
            id: string;
            segment: boolean;
            attributes: {
                fileName: string;
                filePath: string;
                startTime: number;
                stopTime: number;
                participants: string[];
                callType: string;
            };
        };
        type RecordingEventDetail = {
            sessionId: string;
            ani: string;
            agentName: string;
            activeSessionStartTime: number;
            queueName: string;
        };
        type TranscriptionData = {
            Source: string;
            Provider: string;
            id: string;
            fileName: string;
            filePath: string;
            startTime: string;
            languageCode: string;
            createTime: string;
        };
        type TranscriptionJson = {
            interactionId: string;
            languageCode: string;
            responseContents: ResponseContent[];
        };
        type ResponseContent = {
            recognitionResult: RecognitionResult;
        };
        type RecognitionResult = {
            alternatives: Alternative[];
            role: string;
            language_code: string;
        };
        type Alternative = {
            words: Word[];
            transcript: string;
            confidence: number;
        };
        type Word = {
            start_time: StartTime;
            end_time: EndTime;
            word: string;
        };
        type StartTime = {
            seconds: number;
            nanos: number;
        };
        type EndTime = {
            seconds: number;
            nanos: number;
        };
    }
}
export {};
//# sourceMappingURL=qmw-service.d.ts.map