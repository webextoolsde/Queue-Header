import { PrometheusService } from "../prometheus/prometheus-tracking";
import { WebexMetricsService } from "../webexMetrics/webex-metrics-service";
import { CACHE_KEYS, EVENT_CONSTANTS, PROPS_CONSTANTS } from "./constants";
import { FairUsage, RateLimitInfo } from "../../utils/fairUsage";
declare const SERVICE_PROVIDERS: () => {
    prometheus: string;
    webex_behavioral: string;
    webex_operational: string;
    webex_business: string;
};
export declare const DEFAULT_RATE_LIMITS: RateLimitInfo[];
export declare const defaultFairUsageBuilder: (rateLimits?: RateLimitInfo[]) => FairUsage;
export declare class TelemetryService {
    TELEM_EVENT: typeof EVENT_CONSTANTS;
    TELEM_PROPS: typeof PROPS_CONSTANTS;
    TELEM_CACHE_KEYS: typeof CACHE_KEYS;
    SERVICE_PROVIDERS: ReturnType<typeof SERVICE_PROVIDERS>;
    private initialized;
    private readonly webexMetrics?;
    private readonly prometheus?;
    private readonly fairUsage;
    private rateLimitCheckTimer?;
    constructor(webexMetrics?: WebexMetricsService, prometheus?: PrometheusService, fairUsageBuilder?: () => FairUsage);
    private startRateLimitChecking;
    init(): TelemetryService;
    private readonly callbackEventRegister;
    registerCallbackEvent(name: string, callback: (options: any) => void): void;
    track(name: string, options?: any, services?: string[]): void;
    timeEvent(name: string, services?: string[]): void;
    register(superProps: Record<string, any>): void;
    setValueInCache(key: string, value: string | number | boolean): void;
    getValueFromCache(key: string): any;
    removeValueFromCache(key: string): void;
    private trackBehaviouralEvent;
}
export {};
//# sourceMappingURL=telemetry-service.d.ts.map